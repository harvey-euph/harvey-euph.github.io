---
title: "Linux: Process"
description: 一些關於 Linux Process 的隨手記，想到什麼整理什麼
date: 2025-07-24 12:00:00 +0800
categories: [Careers, Linux]
tags: [Tech, Linux]
---

在 Linux 中使用 `struct task_struct` 來管理 process 和 thread，完整結構超過 800 行程式碼，僅在此列出本頁提及的相關項目

```c
struct task_struct {
    // ...
    pid_t pid;
    pid_t tgid;
    // ...
    struct mm_struct *mm;
    // ...
    struct fs_struct *fs;
    // ...
};
```
{: file='linux/include/linux/sched.h'}

```c
struct fs_struct {
    int users;
    seqlock_t seq;
    int umask;
    int in_exec;
    struct path root, pwd;
} __randomize_layout;
```
{: file='linux/include/linux/fs_struct.h'}

```c
struct mm_struct {
    // ...
        struct file __rcu *exe_file;
    // ...
};
```
{: file='linux/include/linux/mm_types.h'}

每個 thread 會擁有一個只屬於自己的 `pid`，並且屬於同一個 process 的 thread 會共用同一個 `tgid`

每個 process 會有一個 main thread，並且使用 main thread 的 `task_struct` 代表這個 process，他的 `pid = tgid`

>`getpid()` 會回傳 `tgid`，`gettid()` 會回傳 `pid`
{: .prompt-info }

為了方便理解，我一律使用 pid 代表 getpid()，tid 代表 gettid()

### `/proc/`

檔案系統中有個目錄 `/proc/<pid>` 專門用來輸出各種和該 `pid` 的 `process` 相關的資訊，會把很多 `task_struct` 內的資訊經過整理放在這裡，只要能理解這個目錄底下的資訊，我們就可以很大程度的了解這個 `process`，最好的是這個方法幾乎不需要任何困難技術就可以觀察到 `task_struct`

要記得使用 `root` 權限來操作，這裡有很多東西都是限制 `root user` 才能操作的

```
harvey@LAPTOP-HARVEY:/proc/1$ sudo su
root@LAPTOP-HARVEY:/proc/1# ls
arch_status      exe                maps           pagemap       stack
attr             fd                 mem            patch_state   stat
auxv             fdinfo             mountinfo      personality   statm
cgroup           gid_map            mounts         projid_map    status
clear_refs       io                 mountstats     root          syscall
cmdline          ksm_merging_pages  net            sched         task
comm             ksm_stat           ns             schedstat     timens_offsets
coredump_filter  latency            numa_maps      sessionid     timers
cpuset           limits             oom_adj        setgroups     timerslack_ns
cwd              loginuid           oom_score      smaps         uid_map
environ          map_files          oom_score_adj  smaps_rollup  wchan
```

當然可以 `sudo ls`，但接下來要往內看細節時也會一直需要 `root` 權限，遇到目錄時甚至沒辦法 `sudo cd` 來進入，因此推薦直接使用 `root` 來操作

這些大部分的內容其實不是真的檔案，是當我們 access 的時候由 kernel 動態生成的虛擬檔案系統（Virtual Filesystem, VFS）

```
root@LAPTOP-HARVEY:/proc/1# ls -l | grep ^d
dr-xr-xr-x  2 root root  0 Aug  9 21:23 attr
dr-x------  2 root root 66 Aug  9 21:23 fd
dr-xr-xr-x  2 root root  0 Aug 10 03:04 fdinfo
dr-x------  2 root root  0 Aug 10 03:04 map_files
dr-xr-xr-x 57 root root  0 Aug  9 21:23 net
dr-x--x--x  2 root root  0 Aug 10 03:04 ns
dr-xr-xr-x  3 root root  0 Aug 10 03:04 task

root@LAPTOP-HARVEY:/proc/1# ls -l | grep ^l
lrwxrwxrwx  1 root root  0 Aug  9 21:23 cwd -> /
lrwxrwxrwx  1 root root  0 Aug  9 21:23 exe -> /usr/lib/systemd/systemd
lrwxrwxrwx  1 root root  0 Aug  9 21:23 root -> /

root@LAPTOP-HARVEY:/proc/1# readlink exe
/usr/lib/systemd/systemd
```

進一步看屬性就會發現有一些是目錄 (`d` 開頭)，還有一些是 `l` 開頭的，這些是符號連結（symlink），對這些項目使用 `readlink` 可以看到 `->` 右側的內容，也就是它們真正代表的檔案或目錄，`exe` 代表的就是 `process` 正在執行的可執行檔

再次強調他們可能不是真正存在於硬碟的檔案，而是在我們觀測的時候生成的臨時檔案，接下來我會整理 `/proc/<pid>` 裡面的各項目的意義﹑生成的函數 (來自 `fs/proc/base.c`)﹑以及對應 `task_struct` 的來源


### 符號連結

假設 `task_struct task;` 是一個 `process` 

| Name   | Access Function    | Target               |
| :----- | :----------------- | :------------------- |
| `cwd`  | `proc_cwd_link()`  | `task->fs->pwd`      |
| `exe`  | `proc_exe_link()`  | `task->mm->exe_file` |
| `root` | `proc_root_link()` | `task->fs->root`     |

