---
title: "Linux Process"
date: 2025-07-24 12:00:00 +0800
categories: [Careers, Notes]
tags: [Tech, Linux]
math: true
---

一些關於 Process 的隨手記，想到什麼整理什麼

在 Linux 中使用 struct task_struct 來記錄 processes 或 threads 的一切資訊

$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a} $$

```c
struct task_struct {
    // ...
	pid_t pid;
	pid_t tgid;
    // ...
};
```
{: file='include/linux/sched.h'}

每個 thread 會擁有一個屬於自己的 pid，並且屬於同一個 process 的 thread 會共用同一個 tgid

檔案系統中有個目錄 `/proc/<tgid>/` 專門用來輸出各種和該 `tgid` 的 `process` 相關的資訊，會把很多 `task_struct` 內的資訊經過整理放在這裡，只要理解這個目錄底下的資訊，我們就可以很大程度的了解這個 process，最好的是這個方法幾乎不使用任何困難技術就可以觀察到 task_struct

要記得使用 root 權限來操作，這裡有很多東西都是限制 root user 才能操作的

```
harvey@LAPTOP-HARVEY:/proc/1$ sudo su
root@LAPTOP-HARVEY:/proc/1# ls
arch_status      exe                maps           pagemap       stack
attr             fd                 mem            patch_state   stat
auxv             fdinfo             mountinfo      personality   statm
cgroup           gid_map            mounts         projid_map    status
clear_refs       io                 mountstats     root          syscall
cmdline          ksm_merging_pages  net            sched         task
comm             ksm_stat           ns             schedstat     timens_offsets
coredump_filter  latency            numa_maps      sessionid     timers
cpuset           limits             oom_adj        setgroups     timerslack_ns
cwd              loginuid           oom_score      smaps         uid_map
environ          map_files          oom_score_adj  smaps_rollup  wchan
```

當然可以 `sudo ls`，但接下來要往內看細節時也會一直需要 `root` 權限，遇到 `dir` 時甚至沒辦法 `sudo cd` 來進入，因此推薦直接使用 `root` 來操作

這些大部分的內容其實不是真的檔案，是當我們 access 的時候由 kernel 動態生成的虛擬檔案系統（Virtual Filesystem, VFS）

```
root@LAPTOP-HARVEY:/proc/1# ls -l | grep ^d
dr-xr-xr-x  2 root root  0 Aug  9 21:23 attr
dr-x------  2 root root 66 Aug  9 21:23 fd
dr-xr-xr-x  2 root root  0 Aug 10 03:04 fdinfo
dr-x------  2 root root  0 Aug 10 03:04 map_files
dr-xr-xr-x 57 root root  0 Aug  9 21:23 net
dr-x--x--x  2 root root  0 Aug 10 03:04 ns
dr-xr-xr-x  3 root root  0 Aug 10 03:04 task

root@LAPTOP-HARVEY:/proc/1# ls -l | grep ^l
lrwxrwxrwx  1 root root  0 Aug  9 21:23 cwd -> /
lrwxrwxrwx  1 root root  0 Aug  9 21:23 exe -> /usr/lib/systemd/systemd
lrwxrwxrwx  1 root root  0 Aug  9 21:23 root -> /

root@LAPTOP-HARVEY:/proc/1# readlink exe
/usr/lib/systemd/systemd
```

進一步看屬性就會發現有一些是目錄，還有一些是 l 開頭的，這些是符號連結（symlink），對這些項目使用 `readlink` 可以看到 `->` 右側的內容，也就是它們真正代表的檔案或目錄，`exe` 代表的就是 `process` 正在執行的二進位檔（可執行檔）



Linux kernel 有一些程式專門整理 `task_struct` 的資訊以檔案的形式存在這裡，應該會寫一篇專門整理這些 linux kernel 的部分以及 `task_struct` 和這些檔案的對應關係，順便以此展開一個 `task_struct` 該討論的細節

### 哪些 Syscalls 會改變 fd table

建立新 fd

| Syscall                         | 說明                      |
| ------------------------------- | ----------------------- |
| `open`, `openat`                | 開啟檔案                    |
| `creat`                         | 建立新檔案（舊式）               |
| `socket`, `socketpair`          | 建立 socket               |
| `pipe`, `pipe2`                 | 建立匿名管道（返回一對 fd）         |
| `eventfd`, `eventfd2`           | 建立事件通知 FD               |
| `signalfd`                      | 建立 signal FD            |
| `timerfd_create`                | 建立定時器 FD                |
| `inotify_init`                  | 建立 inotify FD（用來監控檔案事件） |
| `epoll_create`, `epoll_create1` | 建立 epoll FD             |
| `memfd_create`                  | 建立匿名記憶體檔案（RAM 上的檔案）     |
| `dup`, `dup2`, `dup3`           | 複製一個已存在的 FD             |
| `accept`, `accept4`             | 接受新連線，會回傳新 socket FD    |
| `shm_open`                      | 開啟 POSIX 共享記憶體          |

關閉 fd

| Syscall                      | 說明                            |
| ---------------------------- | ----------------------------- |
| `close`                      | 關閉一個 FD                       |
| `dup2(fd, -1)`（glibc 阻止這種用法） | 會失敗或 crash，理論上若能操作會關閉         |
| `execve`                     | 預設會關掉 `close-on-exec` FD（見下方） |

修改 fd 屬性

| Syscall                  | 說明                                          |
| ------------------------ | ------------------------------------------- |
| `fcntl`                  | 修改 FD flag（如 non-blocking, cloexec）         |
| `dup`, `dup2`, `dup3`    | 新 FD 會指向同樣 object，但不同 FD 數字                 |
| `sendmsg` + `SCM_RIGHTS` | 在 Unix domain socket 中傳送 FD（fd 的接收端會出現新 fd） |

其他會導致 fd 改變的情境

| 情境 / 動作          | 說明                             |
| ---------------- | ------------------------------ |
| `execve`         | 所有 `FD_CLOEXEC` 的 fd 都會自動關閉    |
| `fork` / `clone` | 子程序會複製父程序的 FD（參考關係，不是獨立的 FD 表） |
| `posix_spawn`    | 某些選項會重新排列或關閉特定 fd              |
