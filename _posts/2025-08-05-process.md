---
title: "Linux Process"
date: 2025-07-24 12:00:00 +0800
categories: [Careers, Notes]
tags: [Tech, Linux]
---

一些關於 Process 的隨手記，想到什麼整理什麼

在 Linux 中使用 struct task_struct 來記錄 processes 或 threads 的一切資訊

```c
struct task_struct {
    // ...
	pid_t pid;
	pid_t tgid;
    // ...
};
```
{: file='include/linux/sched.h'}

每個 thread 會擁有一個屬於自己的 pid，並且屬於同一個 process 的 thread 會共用同一個 tgid

檔案系統中有個目錄 `/proc/<tgid>/` 專門用來輸出各種和該 `tgid` 的 `process` 相關的資訊，會把很多 `task_struct` 內的資訊經過整理放在這裡，只要理解這個目錄底下的資訊，我們就可以很大程度的了解這個 process，最好的是這個方法幾乎不使用任何困難技術就可以觀察到 task_struct

要記得使用 root 權限來操作，這裡有很多東西都是限制 root user 才能操作的

```
harvey@LAPTOP-HARVEY:/proc/1$ sudo su
root@LAPTOP-HARVEY:/proc/1# ls
arch_status      gid_map            ns             smaps
attr             io                 numa_maps      smaps_rollup
auxv             ksm_merging_pages  oom_adj        stack
cgroup           ksm_stat           oom_score      stat
clear_refs       latency            oom_score_adj  statm
cmdline          limits             pagemap        status
comm             loginuid           patch_state    syscall
coredump_filter  map_files          personality    task
cpuset           maps               projid_map     timens_offsets
cwd              mem                root           timers
environ          mountinfo          sched          timerslack_ns
exe              mounts             schedstat      uid_map
fd               mountstats         sessionid      wchan
fdinfo           net                setgroups
```

當然可以 `sudo ls`，但下一步要往內看時也會一直需要 root 權限，遇到 dir 時甚至沒辦法 `sudo cd` 來進入，因此推薦直接使用 root 來對這裡進行觀察


Linux kernel 有一些程式專門整理 task_struct 的資訊以檔案的形式存在這裡，應該會寫一篇專門整理這些 linux kernel 的部分以及 task_struct 和這些檔案的對應關係，順便以此展開一個 task_struct 該討論的細節

### 哪些 Syscalls 會改變 fd table

建立新 fd

| Syscall                         | 說明                      |
| ------------------------------- | ----------------------- |
| `open`, `openat`                | 開啟檔案                    |
| `creat`                         | 建立新檔案（舊式）               |
| `socket`, `socketpair`          | 建立 socket               |
| `pipe`, `pipe2`                 | 建立匿名管道（返回一對 fd）         |
| `eventfd`, `eventfd2`           | 建立事件通知 FD               |
| `signalfd`                      | 建立 signal FD            |
| `timerfd_create`                | 建立定時器 FD                |
| `inotify_init`                  | 建立 inotify FD（用來監控檔案事件） |
| `epoll_create`, `epoll_create1` | 建立 epoll FD             |
| `memfd_create`                  | 建立匿名記憶體檔案（RAM 上的檔案）     |
| `dup`, `dup2`, `dup3`           | 複製一個已存在的 FD             |
| `accept`, `accept4`             | 接受新連線，會回傳新 socket FD    |
| `shm_open`                      | 開啟 POSIX 共享記憶體          |

關閉 fd

| Syscall                      | 說明                            |
| ---------------------------- | ----------------------------- |
| `close`                      | 關閉一個 FD                       |
| `dup2(fd, -1)`（glibc 阻止這種用法） | 會失敗或 crash，理論上若能操作會關閉         |
| `execve`                     | 預設會關掉 `close-on-exec` FD（見下方） |

修改 fd 屬性

| Syscall                  | 說明                                          |
| ------------------------ | ------------------------------------------- |
| `fcntl`                  | 修改 FD flag（如 non-blocking, cloexec）         |
| `dup`, `dup2`, `dup3`    | 新 FD 會指向同樣 object，但不同 FD 數字                 |
| `sendmsg` + `SCM_RIGHTS` | 在 Unix domain socket 中傳送 FD（fd 的接收端會出現新 fd） |

其他會導致 fd 改變的情境

| 情境 / 動作          | 說明                             |
| ---------------- | ------------------------------ |
| `execve`         | 所有 `FD_CLOEXEC` 的 fd 都會自動關閉    |
| `fork` / `clone` | 子程序會複製父程序的 FD（參考關係，不是獨立的 FD 表） |
| `posix_spawn`    | 某些選項會重新排列或關閉特定 fd              |
