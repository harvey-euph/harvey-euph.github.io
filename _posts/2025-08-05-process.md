---
title: "Linux Process"
date: 2025-07-24 12:00:00 +0800
categories: [Careers, Notes]
tags: [Tech, Linux]
---

一些關於 Process 的隨手記，想到什麼整理什麼

在 Linux 中使用 struct task_struct 來代表 processes 或 threads
有一個方法可以在幾乎不使用任何技術的方式觀察 task_struct，那就是去看 `/proc/<pid>/` 底下的資訊

```text
root@LAPTOP-HARVEY:/proc/1# ls
arch_status      gid_map            ns             smaps
attr             io                 numa_maps      smaps_rollup
auxv             ksm_merging_pages  oom_adj        stack
cgroup           ksm_stat           oom_score      stat
clear_refs       latency            oom_score_adj  statm
cmdline          limits             pagemap        status
comm             loginuid           patch_state    syscall
coredump_filter  map_files          personality    task
cpuset           maps               projid_map     timens_offsets
cwd              mem                root           timers
environ          mountinfo          sched          timerslack_ns
exe              mounts             schedstat      uid_map
fd               mountstats         sessionid      wchan
fdinfo           net                setgroups
```
pre.lineno { display: none; }

Linux kernel 有一些程式專門整理 task_struct 的資訊以檔案的形式存在這裡，應該會寫一篇專門整理這些 linux kernel 的部分以及 task_struct 和這些檔案的對應關係，順便以此展開一個 task_struct 該討論的細節

### 哪些 Syscalls 會改變 fd table

建立新 fd

| Syscall                         | 說明                      |
| ------------------------------- | ----------------------- |
| `open`, `openat`                | 開啟檔案                    |
| `creat`                         | 建立新檔案（舊式）               |
| `socket`, `socketpair`          | 建立 socket               |
| `pipe`, `pipe2`                 | 建立匿名管道（返回一對 fd）         |
| `eventfd`, `eventfd2`           | 建立事件通知 FD               |
| `signalfd`                      | 建立 signal FD            |
| `timerfd_create`                | 建立定時器 FD                |
| `inotify_init`                  | 建立 inotify FD（用來監控檔案事件） |
| `epoll_create`, `epoll_create1` | 建立 epoll FD             |
| `memfd_create`                  | 建立匿名記憶體檔案（RAM 上的檔案）     |
| `dup`, `dup2`, `dup3`           | 複製一個已存在的 FD             |
| `accept`, `accept4`             | 接受新連線，會回傳新 socket FD    |
| `shm_open`                      | 開啟 POSIX 共享記憶體          |

關閉 fd

| Syscall                      | 說明                            |
| ---------------------------- | ----------------------------- |
| `close`                      | 關閉一個 FD                       |
| `dup2(fd, -1)`（glibc 阻止這種用法） | 會失敗或 crash，理論上若能操作會關閉         |
| `execve`                     | 預設會關掉 `close-on-exec` FD（見下方） |

修改 fd 屬性

| Syscall                  | 說明                                          |
| ------------------------ | ------------------------------------------- |
| `fcntl`                  | 修改 FD flag（如 non-blocking, cloexec）         |
| `dup`, `dup2`, `dup3`    | 新 FD 會指向同樣 object，但不同 FD 數字                 |
| `sendmsg` + `SCM_RIGHTS` | 在 Unix domain socket 中傳送 FD（fd 的接收端會出現新 fd） |

其他會導致 fd 改變的情境

| 情境 / 動作          | 說明                             |
| ---------------- | ------------------------------ |
| `execve`         | 所有 `FD_CLOEXEC` 的 fd 都會自動關閉    |
| `fork` / `clone` | 子程序會複製父程序的 FD（參考關係，不是獨立的 FD 表） |
| `posix_spawn`    | 某些選項會重新排列或關閉特定 fd              |
