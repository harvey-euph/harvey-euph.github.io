---
title: "DPDK 自學紀錄 - 持續更新中"
date: 2025-10-28 00:00:00 +0800
categories: [Careers, Tech]
tags: [DPDK, Tech]
---

## WHAT

`DPDK` 是個主要以 `C` 寫成的開源套件，全名 `Data Plane Development Kit`，主要用來高效的處理網路封包相關任務，目標是繞過 `OS kernel` 的網路協議棧，全部的處理都在用戶端用最有效率的方式完成。

## WHY

會想學 `DPDK` 的原因是我的目標是有一天能進入 `HFT` 負責 `low-latency` 相關的軟體職位，我覺得能用盡一切快還要更快是一件相當有挑戰性而且有趣的事，並且能在 `HFT` 擁有相對應的實際產值。很多這類職缺都不約而同的提到了 `DPDK`，起初看了一下發現似乎需要滿足條件的特殊硬體才能學，但是進一步研究之後發現其實硬體不滿足的情況下也可以在軟體端先學一些東西，主要的努力也是軟體的使用，因此就下定決心要把 `DPDK` 掌握起來。

另外，學習 `DPDK` 似乎可以順便掌握網路協議相關知識以及各種軟硬體優化技巧，覺得是非常一石二鳥的好東西。

## HOW

研究了一下的他的 `examples` 和 `app` 內容非常豐富，並且 `Doc` 完整，學起來似乎非常有跡可循，所以目標就是慢慢把 `examples` 先按照順序 pick up 起來，看不懂的東西就去找官方文檔或者問 `LLM`，搭配實際操作來練習，希望能盡快掌握並且實際應用在專案裡面

## PREGRESS

### 總整理

`DPDK` 有幾個核心元素，包含 `rte_ring`, `rte_mempool`, `rte_mbuf`, ... (未寫完，會慢慢補齊)

據 [學習影片](https://www.bilibili.com/video/BV1nCJkzXEJS) 的說法

- 曾經網路只在 `kernel` 工作，有了 `DPDK` 之後就可以在用戶端對網路封包做更彈性的操作，加上 `DPDK` 有強大的商業研發團隊，文檔齊全，並且有以下框架可以使用: `VPP (C/C++)`, `OvS`, `NFF-GO`, `SNABB(LUA)`, `SPDK(C)`

- `DPDK` 的實現方法:

    - kernel driver: igb_uio, vfio, kni
    - memory: mempool, mbuf
    - 協議: ipsec, bpf, pci, flow_classify
    - 虛擬化: vhost, virtio
    - CPU: affinity, RCU, sched
    - 安全: security, cryptodev, compressdev

- 需要考慮的性能議題:

    - 吞吐量 BPS
    - 拆鏈/建鍊 pps
    - 併發
    - Latency
    - 丟包率

### 讀過的文件

- Programmer’s Guide: [intro](https://doc.dpdk.org/guides-25.07/prog_guide/intro.html)

文中有一張相當清楚的部件關係圖 ![圖片](https://doc.dpdk.org/guides-25.07/_images/architecture-overview.svg)

- testpmd 相關: [intro](https://doc.dpdk.org/guides-25.07/testpmd_app_ug/intro.html), [build_app](https://doc.dpdk.org/guides-25.07/testpmd_app_ug/build_app.html), [run_app](https://doc.dpdk.org/guides-25.07/testpmd_app_ug/run_app.html) (太多參數了，要用到再回來找)

- examples 相關: [hello_world](https://doc.dpdk.org/guides-25.07/sample_app_ug/hello_world.html)


### 讀過的程式碼

- `examples/helloworld`
: `DPDK` 的 EAL 環境建立和收拾，參數給定的方式，以及 `CPU` 核心 (這裡稱作 `lcore`) 的操作。

- `examples/cmdline`
: `DPDK` 的程式和用戶互動的工具，實際應用中可以在運行中在終端用簡易指令操控程式行為。

- `examples/timer`
: `DPDK` 中的時間等待相關功能，和一般的 `timer` 不同的是，需要 `CPU` 主動確認才會觸發回調函數，觸發的時機和頻率也是用戶可以自己決定的，給予用戶高彈性。

- `examples/skeleton`
: 最基礎實際 `DPDK` 運用的骨幹，包含網卡的 `port` (和 `TCP` 的 `port` 不同，要注意分別，此處涉及的 `port` 是 `L2` 的概念，`TCP` 的是 `L4` 的概念)﹑記憶體的獲取操作，以及網路封包的讀寫。

- `examples/l2fwd`
: 學習標準的參數 `parse` 功能以及 `signal handle` 的方式，也用到 `timer`。

- `examples/multi_process/simple_mp`
: `DPDK` 使用環形緩衝區 `rte_ring` 實現進程間通信 (要注意此範例中 `rte_ring` 只存指標，實際 message 內容是存在 `rte_mempool` 裡面)

### 自己嘗試實現的東西

- 進行 `L2` - `L4` 常見網路協議進行處理
    - 解析 `MAC`﹑`IPV4`﹑`UDP & TCP port` 以及其 content

- 處理 `ARP` 和 `ICMP` 的回應成功，相同條件下 `ping` `linux kernel` 的協議棧平均反應時間是 `0.14 ms`，`DPDK` 的則是 `0.125 ms`，算是真的稍為有比較快，之後還要學完整的效能檢測操作。

### 其他注意到的事 / 心得

- `rte_mempool` 的設計似乎超乎想像的巧妙 & 有彈性，可以讓用戶在建立 `pool` 的時候決定要用哪一種 `pool` 的底層實作，可以是依賴 `rte_ring` 的預設實作，也可以採用其他的，所有選項都放在 `drivers/mempool` 裡面，介面的設計也非常彈性，值得學習 (`lib/mempool/rte_mempool.h` 的 `struct rte_mempool_ops`)

我的實際操作指令和細節放在 [這篇](/posts/dpdk-impl)