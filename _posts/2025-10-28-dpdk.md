---
title: "DPDK 自學紀錄 - 持續更新中"
date: 2025-11-15 00:00:00 +0800
categories: [Careers, Tech]
tags: [DPDK, Tech]
---

## PLAN

### WHAT

`DPDK` 是個以 `C` 寫成的開源套件，全名 `Data Plane Development Kit`，是個用來高效的處理網路封包相關任務，透過在用戶端實作封包處理繞過 `OS kernel` 的網路協議棧來達到極致的高效。

### WHY

會想學 `DPDK` 的原因是我希望有一天能在 `HFT` 擔任 `low-latency` 相關的職位，我覺得能用盡一切技術快還要更快是一件相當有挑戰性而且有趣的事，並且能在 `HFT` 擁有相對應的實際產值。看到部分這類職缺提到了 `DPDK`，起初覺得似乎需要滿足條件的特殊硬體才能學，但是進一步研究之後發現其實硬體不滿足的情況下也可以在軟體端先掌握一些東西，主要的努力也是軟體的使用，因此就下定決心要把 `DPDK` 學起來。

另外，學習 `DPDK` 似乎可以順便掌握網路協議相關知識 `(L2-L4)` 以及各種軟硬體優化技巧 (如 `ring buffer`)，覺得是非常一石二鳥的好事。

### HOW

研究了一下的他的 `examples` 和 `app` 內容非常豐富，並且 `Doc` 完整，學起來似乎非常有跡可循，所以目標就是慢慢把 `examples` 先按照順序 pick up 起來，看不懂的東西就去找官方文檔或者問 `LLM`，搭配實際操作來練習，希望能盡快掌握並且實際應用在專案裡面

### DETAILS

`DPDK` 有幾個核心元素，包含 `rte_ring`, `rte_mempool`, `rte_mbuf`, ... (未寫完，會慢慢補齊)

據 [學習影片](https://www.bilibili.com/video/BV1nCJkzXEJS) 的說法

- 曾經網路只在 `kernel` 工作，有了 `DPDK` 之後就可以在用戶端對網路封包做更彈性的操作，加上 `DPDK` 有強大的商業研發團隊，文檔齊全，並且有以下框架可以使用: `VPP (C/C++)`, `OvS`, `NFF-GO`, `SNABB(LUA)`, `SPDK(C)`

- `DPDK` 的實現方法:

    - kernel driver: `igb_uio`, `vfio`, `kni`
    - memory: `mempool`, `mbuf`
    - 協議: `ipsec`, `bpf`, `pci`, `flow_classify`
    - 虛擬化: `vhost`, `virtio`
    - CPU: `affinity`, `RCU`, `sched`
    - 安全: `security`, `cryptodev`, `compressdev`

- 需要考慮的性能議題:

    - 吞吐量 BPS, 拆鏈/建鍊 pps, 併發, Latency, 丟包率,
    
## PREGRESS

### 讀過的文件

- Programmer’s Guide: [intro](https://doc.dpdk.org/guides-25.07/prog_guide/intro.html)

文中有一張相當清楚的部件關係圖 

<object id="dpdk-arch" type="image/svg+xml"
        data="https://doc.dpdk.org/guides-25.07/_images/architecture-overview.svg">
</object>


- testpmd 相關: [intro](https://doc.dpdk.org/guides-25.07/testpmd_app_ug/intro.html), [build_app](https://doc.dpdk.org/guides-25.07/testpmd_app_ug/build_app.html), [run_app](https://doc.dpdk.org/guides-25.07/testpmd_app_ug/run_app.html) (太多參數了，要用到再回來找)

- examples 相關: [hello_world](https://doc.dpdk.org/guides-25.07/sample_app_ug/hello_world.html)


### 讀過的程式碼

- `examples/helloworld`
: `DPDK` 的 `EAL` 環境建立和收拾，參數給定的方式，以及 `CPU` 核心 (這裡稱作 `lcore`) 的操作。

- `examples/cmdline`
: `DPDK` 的程式和用戶互動的工具，實際應用中可以在運行中在終端用簡易指令操控程式行為。

- `examples/timer`
: `DPDK` 中的時間等待相關功能，和一般的 `timer` 不同的是，需要 `CPU` 主動確認才會觸發回調函數，觸發的時機和頻率也是用戶可以自己決定的，給予用戶高彈性。

- `examples/skeleton`
: 最基礎實際 `DPDK` 運用的骨幹，包含網卡的 `port` (和 `TCP` 的 `port` 不同，要注意分別，此處涉及的 `port` 是 `L2` 的概念，`TCP` 的是 `L4` 的概念)﹑記憶體的獲取操作，以及網路封包的讀寫。

- `examples/rxtx_callbacks`
: 使用 `examples/skeleton` 的架構展示了收發訊息時的 `callback function` 功能，無論是否有新送出/接收都會呼叫，並且 `callback function` 必須有指定格式的參數，似乎還可以配置多個 `callback function` 來依序呼叫 (`TODO` 未實驗，找機會試試看)

```c
typedef uint16_t (*rte_rx_callback_fn)(uint16_t port_id, uint16_t queue,
	struct rte_mbuf *pkts[], uint16_t nb_pkts, uint16_t max_pkts,
	void *user_param);
    
typedef uint16_t (*rte_tx_callback_fn)(uint16_t port_id, uint16_t queue,
	struct rte_mbuf *pkts[], uint16_t nb_pkts, void *user_param);
```

<!-- - `examples/l2fwd` -->
<!-- : 學習標準的參數 `parse` 功能以及 `signal handle` 的方式，也用到 `timer`。 -->

- `examples/multi_process/simple_mp`
: `DPDK` 使用環形緩衝區 `rte_ring` 實現進程間通信 (要注意此範例中 `rte_ring` 只存指標，實際 message 內容是存在 `rte_mempool` 裡面)

- `examples/packet_ordering`
: 封包重排，可以在多執行緒的情形下依照 `RX` 順序而不受 `worker` 處理延遲影響送 `TX` (`TODO` 要加上隨機延遲，並且用 TX cb 來觀察行為，看看是否真的會因為 `--disable-reorder` 而改變行為) (似乎還是實驗功能，行為會因為版本而改變，要使用的話要注意)

- `examples/l3fwd`

還沒看懂，不知道為什麼要改程式才跑得起來

```diff
diff --git a/examples/l3fwd/main.c b/examples/l3fwd/main.c
@@ -125,8 +125,8 @@ static uint16_t nb_lcore_params = sizeof(lcore_params_array_default) /
 
 static struct rte_eth_conf port_conf = {
     .rxmode = {
-        .mq_mode = RTE_ETH_MQ_RX_RSS,
-        .offloads = RTE_ETH_RX_OFFLOAD_CHECKSUM,
+        .mq_mode = RTE_ETH_MQ_RX_NONE,
+        .offloads = 0,
     },
     .rx_adv_conf = {
     .rss_conf = {
```
{: .nolineno }

`sudo ./build/l3fwd -l 1,2 -- -p 0x3 --config="(0,0,1),(1,0,2)"`

跑起來也不知道做了什麼事，還要再看一下程式碼

- 會學到的東西

    - `LPM (Longest Prefix Match)`: 決定封包往哪送的演算法

### 自己嘗試實現的東西

- 進行 `L2` - `L4` 常見網路協議進行處理
    - 解析 `MAC`﹑`IPV4`﹑`UDP & TCP port` 以及其 content

- 處理 `ARP` 和 `ICMP` 的回應成功，相同條件下 `ping` `linux kernel` 的協議棧平均反應時間是 `0.14 ms`，`DPDK` 的則是 `0.125 ms`，算是真的稍微有比較快，之後還要學完整的效能檢測操作。

### 其他注意到的事 / 心得

- `rte_mempool` 的設計似乎超乎想像的巧妙 & 有彈性，可以讓用戶在建立 `pool` 的時候決定要用哪一種 `pool` 的底層實作，可以是依賴 `rte_ring` 的預設實作，也可以採用其他的，所有選項都放在 `drivers/mempool` 裡面，介面的設計也非常彈性，值得學習 (`lib/mempool/rte_mempool.h` 的 `struct rte_mempool_ops`)

- 網卡的操作可以用 `usertools/dpdk-devbind.py` 來協助，可以看網卡狀態以及綁定 (需 `sudo` 權限)﹑解除。

- `rte_ring` 可以用 `DPDK` 內部的記憶體來創建 (`rte_ring_create`)，也可以自己準備好記憶體來初始化 (`rte_ring_init`)，前者會幫你寫在 `rte_ring_list` 讓你可以進行查找 (`rte_ring_lookup`)，後者則不會被找到

- 要學的英文縮寫很多，以下列出我新學到的東西:

    - `IOMMU`: 
    - `vfio/uio`:
    - 

### 其他來源

- [wiles super](https://www.zhihu.com/people/wiles-super) 的知乎專欄

    - [DPDK 終極大殺器Event Dev API (一) 源起](https://zhuanlan.zhihu.com/p/27990594)

## 操作紀錄

使用版本 v25.07

```sh
git clone http://dpdk.org/git/dpdk && cd dpdk
git checkout -b v25.07 v25.07
meson build -Dexamples=all -Dtests=true
ninja -C build
sudo ninja -C build install
sudo ldconfig
```

一番操作之後就編譯和安裝就完成了，之後每次要編譯只要回到 `dpdk` 使用 `ninja -C build` 或是用 `example/xxx` 裡面的 `Makefile` 就可以重新編譯。

運行還需要其他設置:

- DPDK 是一個接管整個網卡的應用程式，一旦把一張網卡交給他就會失去所有那張網卡該有的功能，要維持電腦其他網路功能的話就必須留著一張主網卡

```sh
sudo modprobe vfio-pci
sudo ifconfig ens37 down
sudo ifconfig ens38 down
cd /path/to/dpdk
./usertools/dpdk-devbind.py --status
sudo ./usertools/dpdk-devbind.py --bind=vfio-pci --noiommu-mode 0000:02:05.0
sudo ./usertools/dpdk-devbind.py --bind=vfio-pci --noiommu-mode 0000:02:06.0
```

- 需要設置 huge page

```sh
echo 512 | sudo tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
cat /proc/meminfo | grep Huge
```
