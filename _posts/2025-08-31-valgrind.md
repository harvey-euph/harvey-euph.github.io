---
title: "Valgrind 練習"
description: "記錄我從頭開始學習 valgrind 的用法和例子，有時間的話會再去了解背後的運作"
date: 2025-08-30 12:00:00 +0800
categories: [Careers, Linux]
tags: [Tech, Linux, Valgrind]
---

valgrind 是一個我長期聽說方便對記憶體 debug 的工具，所以來學學看一些基本操作，看之後會不會讓我更會 debug。

### Installation

```sh
sudo apt update
sudo apt install valgrind
```

### Memory Leakage

```c
#include <stdlib.h>

int main()
{
    int *arr = malloc(10 * sizeof(int));
    arr[0] = 123;
    // free(arr);
    return 0;  
}
```
{: file='leak.c'}

```
gcc -g -o leak leak.c
valgrind --leak-check=full ./leak

==155409== Memcheck, a memory error detector
==155409== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==155409== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==155409== Command: ./leak
==155409== 
==155409== 
==155409== HEAP SUMMARY:
==155409==     in use at exit: 40 bytes in 1 blocks
==155409==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated
==155409== 
==155409== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
==155409==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==155409==    by 0x10913B: main (leak.c:5)
==155409== 
==155409== LEAK SUMMARY:
==155409==    definitely lost: 40 bytes in 1 blocks
==155409==    indirectly lost: 0 bytes in 0 blocks
==155409==      possibly lost: 0 bytes in 0 blocks
==155409==    still reachable: 0 bytes in 0 blocks
==155409==         suppressed: 0 bytes in 0 blocks
==155409== 
==155409== For lists of detected and suppressed errors, rerun with: -s
==155409== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```

```

If we add back the free(arr) and compile again:

{% toggle gcc -g -o leak leak.c<br>valgrind --leak-check=full ./leak %}

==155886== Memcheck, a memory error detector
==155886== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==155886== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==155886== Command: ./leak
==155886== 
==155886== 
==155886== HEAP SUMMARY:
==155886==     in use at exit: 0 bytes in 0 blocks
==155886==   total heap usage: 1 allocs, 1 frees, 40 bytes allocated
==155886== 
==155886== All heap blocks were freed -- no leaks are possible
==155886== 
==155886== For lists of detected and suppressed errors, rerun with: -s
==155886== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

{% endtoggle %}

### Invalid Write

```c
#include <stdlib.h>

int main() {
    int *arr = malloc(5 * sizeof(int));
    for (int i = 0; i <= 5; i++) {  // Should be < 5
        arr[i] = i;
    }
    free(arr);
    return 0;
}
```
{: file='invalid_write.c'}

```sh
gcc -g -o invalid_write invalid_write.c
valgrind ./invalid_write

Invalid write of size 4
   at  main (invalid_write.c:7)
 Address 0x... is 0 bytes after a block of size 20 alloc'd

```

### Use After Free

```c
#include <stdlib.h>
#include <stdio.h>

int main()
{
    int *x = malloc(sizeof(int));
    *x = 42;
    free(x);
    printf("%d\n", *x);
    return 0;
}
```
{: file='use_after_free.c'}

```sh
gcc -g -o use_after_free use_after_free.c
valgrind ./use_after_free

Invalid read of size 4
   at  main (use_after_free.c:9)
 Address 0x... is 0 bytes inside a block of size 4 free'd

```

### Uninitialized Memory

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    int *x = malloc(sizeof(int));
    printf("%d\n", *x);
    free(x);
    return 0;
}
```
{: file='uninit.c'}

```sh
gcc -g -o un-init un-init.c
valgrind ./un-init

Use of uninitialised value of size 4
   at  main (un-init.c:8)
```

{% exec %}

code-to-execute

---

output

{% endexec %}