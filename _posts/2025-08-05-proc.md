---
title: "從 proc 開始看 Linux 的 Process"
description: 一些關於 Process 的隨手記，想到什麼就整理什麼
date: 2025-08-11 12:00:00 +0800
categories: [Careers, Linux]
tags: [Tech, Linux]
---

Linux 使用 `struct task_struct` 來管理 `process` 和 `thread`，完整結構超過 800 行程式碼，僅在此列出本頁將提及的相關項目

```c
struct task_struct {
    // ...
    pid_t pid;
    pid_t tgid;
    // ...
    struct mm_struct *mm;
    // ...
    struct fs_struct *fs;
    // ...
};
```
{: file='linux/include/linux/sched.h'}

從現在起讓 `struct task_struct *task;`

## 基礎知識

每個 `task_struct` 會擁有一個屬於自己獨一無二的 `pid`，但其實 `task_struct` 代表的是 `thread` 而非 `process`，`process` 其實是 `thread group` 的概念，將多個 `thread` 的 `task_struct` 使用共同的 `tgid` (意思是 `thread group id` ) 來標示這些 `task_struct` 屬於同一個 `process` (通常 `fs` 和 `mm` 也會是共用的)，每個 `thread group` 會有一個 `main thread`，他的 `task->pid == task->tgid`

>`getpid()` 對應到 `task->tgid`，`gettid()` 對應到 `task->pid`
{: .prompt-info }

為了方便理解，我一律使用 `pid` 代表 `getpid()` 得到的結果，`tid` 代表 `gettid()` 得到的結果

檔案系統中有個目錄 `/proc/<pid>` 專門用來輸出各種和該 `pid` 對應的 `process` 相關的資訊，透過這個目錄底下的資訊，我們就能很大程度了解這個 `process`，最棒的是這個方法不需要任何困難技術就可以觀察到 `task_struct`，因此我想要以此目錄展開各項關於 `process` 和 `thread` 的細節。

要記得 `sudo su` 來使用 `root` 權限，很多操作都需要 `root`[^fn1]

```
harvey@LAPTOP-HARVEY:/proc/1$ sudo su
root@LAPTOP-HARVEY:/proc/1# ls
arch_status      exe                maps           pagemap       stack
attr             fd                 mem            patch_state   stat
auxv             fdinfo             mountinfo      personality   statm
cgroup           gid_map            mounts         projid_map    status
clear_refs       io                 mountstats     root          syscall
cmdline          ksm_merging_pages  net            sched         task
comm             ksm_stat           ns             schedstat     timens_offsets
coredump_filter  latency            numa_maps      sessionid     timers
cpuset           limits             oom_adj        setgroups     timerslack_ns
cwd              loginuid           oom_score      smaps         uid_map
environ          map_files          oom_score_adj  smaps_rollup  wchan
```

這些內容其實不是真的存在於硬碟的檔案，是當我們 access 的時候由 kernel 動態生成的虛擬檔案系統 `(Virtual Filesystem, VFS)`

這些項目是由 `linux/fs/proc/base.c` 的這段程式碼決定的:

```c
/*
 * Thread groups
 */
static const struct file_operations proc_task_operations;
static const struct inode_operations proc_task_inode_operations;

static const struct pid_entry tgid_base_stuff[] = {
    DIR("task",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),
    DIR("fd",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),
    // ...
}
```
{: file='linux/fs/proc/base.h'}

可以看到上面定義的 `DIR("task", /* ... */)` 定義了 `/proc/<pid>/` 底下會有一個目錄 `task`，再進去一看會發現裡面有一些以數字命名的目錄

```
root@LAPTOP-HARVEY:/proc/76/task# ls -l
total 0
dr-xr-xr-x 7 root root 0 Aug 10 17:01 76
dr-xr-xr-x 7 root root 0 Aug 10 17:01 78
dr-xr-xr-x 7 root root 0 Aug 10 17:01 79
```

代表著這個 `process` 底下的每個 `threads` 的 `tid`，會發現有一個 `tid` 和 `pid` 相等，它就是代表那個 `main thread` 的 `task_struct`

再進到任意一個目錄 (例如 `78`) 會發現 `/proc/<pid>/` 和 `/proc/<pid>/task/<tid>` 的內容非常相似

```
root@LAPTOP-HARVEY:/proc/76/task/78# ls
arch_status  environ            loginuid   oom_score_adj  smaps
attr         exe                maps       pagemap        smaps_rollup
auxv         fd                 mem        patch_state    stack
cgroup       fdinfo             mountinfo  personality    stat
children     gid_map            mounts     projid_map     statm
clear_refs   io                 net        root           status
cmdline      ksm_merging_pages  ns         sched          syscall
comm         ksm_stat           numa_maps  schedstat      uid_map
cpuset       latency            oom_adj    sessionid      wchan
cwd          limits             oom_score  setgroups
```

但其是是稍微不同的，定義在同一個檔案的另一個區塊

```c
/*
 * Tasks
 */
static const struct pid_entry tid_base_stuff[] = {
    DIR("fd",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),
    DIR("fdinfo",    S_IRUGO|S_IXUGO, proc_fdinfo_inode_operations, proc_fdinfo_operations),
    DIR("ns",        S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),
    // ...
}
```
{: file='linux/fs/proc/base.h'}

可以很明顯發現這裡比上面少了 `DIR("task", /* ... */)` 的目錄，因為這是只有外層才有意義的條目

我也還沒仔細研究到底其他內容的關係是什麼，但大致上 `/proc/<pid>/` 就是 `/proc/<pid>/task/<tid>` 的統合資料，`/proc/<pid>/task/<tid>` 則是各自 `thread` 自己的資料

比對了一下發現還少了: `coredump_filter map_files mountstats timens_offsets timers timerslack_ns` 之後會再慢慢搞懂差異

也還不確定 `/proc/<pid>/task/<pid>` 和 `/proc/<pid>` 是不是共有的東西都一樣，日後會慢慢補充，我也還在學

接下來我們來看看這些成員被定義的方式

```c
struct pid_entry {
    const char *name;
    unsigned int len;
    umode_t mode;
    const struct inode_operations *iop;
    const struct file_operations *fop;
    union proc_op op;
};

#define NOD(NAME, MODE, IOP, FOP, OP) {             \
    .name = (NAME),                                 \
    .len  = sizeof(NAME) - 1,                       \
    .mode = MODE,                                   \
    .iop  = IOP,                                    \
    .fop  = FOP,                                    \
    .op   = OP,                                     \
}

#define DIR(NAME, MODE, iops, fops)                 \
    NOD(NAME, (S_IFDIR|(MODE)), &iops, &fops, {} )
#define LNK(NAME, get_link)                         \
    NOD(NAME, (S_IFLNK|S_IRWXUGO),                  \
        &proc_pid_link_inode_operations, NULL,      \
        { .proc_get_link = get_link } )
#define REG(NAME, MODE, fops)                       \
    NOD(NAME, (S_IFREG|(MODE)), NULL, &fops, {})
#define ONE(NAME, MODE, show)                       \
    NOD(NAME, (S_IFREG|(MODE)),                     \
        NULL, &proc_single_file_operations,         \
        { .proc_show = show } )
#define ATTR(LSMID, NAME, MODE)                     \
    NOD(NAME, (S_IFREG|(MODE)),                     \
        NULL, &proc_pid_attr_operations,            \
        { .lsmid = LSMID })
```
{: file='linux/fs/proc/base.h'}

決定有哪些項目﹑各自是什麼類型﹑接受什麼操作，以下依序介紹

以下逐一介紹重要項目

## 符號連結

在 linux 中有些檔案代表的是一個指向其他路徑的符號連結 `(symlink)`，對這些項目使用 `readlink` 可以看到他們指向的目標

`/proc/<pid>/` 和 `/proc/<pid>/task/<tid>` 裡面也都有這種檔案，也就是上述使用 `LNK` 定義的成員

```c
    LNK("cwd",       proc_cwd_link),
    LNK("root",      proc_root_link),
    LNK("exe",       proc_exe_link),
```
{: file='linux/fs/proc/base.h'}

就會對應到這裡的輸出

```
root@LAPTOP-HARVEY:/proc/1# ls -l | grep ^l
lrwxrwxrwx  1 root root  0 Aug  9 21:23 cwd -> /
lrwxrwxrwx  1 root root  0 Aug  9 21:23 exe -> /usr/lib/systemd/systemd
lrwxrwxrwx  1 root root  0 Aug  9 21:23 root -> /

root@LAPTOP-HARVEY:/proc/1# readlink exe
/usr/lib/systemd/systemd
```

- cwd 代表的是 Current working directory，對應到 `task->fs->pwd`
- exe 是 Executable file path，對應到 `task->mm->exe_file`
- root 則是這個 process 的 root 路徑，對應到 `task->fs->root`

對一個 process 來說 root 不一定是整個系統的 root，改變一個 process 的 root 有其用處，可以參考[這篇](/posts/chroot)

以下附上用到的 `fs` 和 `mm` 內容結構

```c
struct fs_struct {
    int users;
    seqlock_t seq;
    int umask;
    int in_exec;
    struct path root, pwd;
} __randomize_layout;
```
{: file='linux/include/linux/fs_struct.h'}

`mm_struct` 也很大，先放一部分，之後有用到更多成員會再貼更多上來

```c
struct mm_struct {
    // ...
        struct file __rcu *exe_file;
    // ...
};
```
{: file='linux/include/linux/mm_types.h'}

## 目錄

類似於上述的 `task`，也有其他用 `DIR` 定義的目錄，我們可以用這個指令來看

```
root@LAPTOP-HARVEY:/proc/1# ls -l | grep ^d
dr-xr-xr-x  2 root root  0 Aug 11 16:11 attr
dr-x------  2 root root 66 Aug 11 16:11 fd
dr-xr-xr-x  2 root root  0 Aug 11 19:11 fdinfo
dr-x------  2 root root  0 Aug 11 19:11 map_files
dr-xr-xr-x 56 root root  0 Aug 11 16:11 net
dr-x--x--x  2 root root  0 Aug 11 19:11 ns
dr-xr-xr-x  3 root root  0 Aug 11 19:11 task
```

`task` 裡面一層的目錄也一樣，少了幾個項目但大致一樣

```
root@LAPTOP-HARVEY:/proc/1# ls task/1/ -l | grep ^d
dr-xr-xr-x  2 root root  0 Aug 12 03:15 attr
dr-x------  2 root root 66 Aug 12 03:15 fd
dr-xr-xr-x  2 root root  0 Aug 12 03:15 fdinfo
dr-xr-xr-x 56 root root  0 Aug 12 03:15 net
dr-x--x--x  2 root root  0 Aug 12 03:15 ns
```

差異除了 task 自己之外，就是 `map_files` 了，這個是一個大主題，所以[另開一篇](/posts/map_files_and_maps)講，也因為會和另一個檔案 `maps` 高度相關，因此會一起講

### fd 和 fdinfo

```
root@LAPTOP-HARVEY:/proc/65# ls -l fd
total 0
lr-x------ 1 root root 64 Aug 10 17:39 0 -> /dev/null
lrwx------ 1 root root 64 Aug 10 17:39 1 -> 'socket:[12310]'
lrwx------ 1 root root 64 Aug 10 17:39 10 -> 'anon_inode:[signalfd]'
lrwx------ 1 root root 64 Aug 10 17:39 11 -> 'anon_inode:[timerfd]'
lr-x------ 1 root root 64 Aug 10 17:39 12 -> /usr/lib/udev/hwdb.bin
lrwx------ 1 root root 64 Aug  9 21:23 13 -> 'anon_inode:[timerfd]'
lrwx------ 1 root root 64 Aug 10 17:39 2 -> 'socket:[12310]'
lrwx------ 1 root root 64 Aug  9 21:23 3 -> 'socket:[7229]'
lrwx------ 1 root root 64 Aug  9 21:23 4 -> 'socket:[7231]'
lrwx------ 1 root root 64 Aug 10 17:39 5 -> 'socket:[1990]'
lrwx------ 1 root root 64 Aug 10 17:39 6 -> 'socket:[1992]'
lrwx------ 1 root root 64 Aug 10 17:39 7 -> 'socket:[1993]'
lr-x------ 1 root root 64 Aug 10 17:39 8 -> anon_inode:inotify
lrwx------ 1 root root 64 Aug 10 17:39 9 -> 'anon_inode:[eventpoll]'
```

```
root@LAPTOP-HARVEY:/proc/65# ls -l fdinfo/
total 0
-r--r--r-- 1 root root 0 Aug 10 17:39 0
-r--r--r-- 1 root root 0 Aug 10 17:39 1
-r--r--r-- 1 root root 0 Aug 10 17:39 10
-r--r--r-- 1 root root 0 Aug 10 17:39 11
-r--r--r-- 1 root root 0 Aug 10 17:39 12
-r--r--r-- 1 root root 0 Aug 10 17:39 13
-r--r--r-- 1 root root 0 Aug 10 17:39 2
-r--r--r-- 1 root root 0 Aug 10 17:39 3
-r--r--r-- 1 root root 0 Aug 10 17:39 4
-r--r--r-- 1 root root 0 Aug 10 17:39 5
-r--r--r-- 1 root root 0 Aug 10 17:39 6
-r--r--r-- 1 root root 0 Aug 10 17:39 7
-r--r--r-- 1 root root 0 Aug 10 17:39 8
-r--r--r-- 1 root root 0 Aug 10 17:39 9
```

```
root@LAPTOP-HARVEY:/proc/65# cat fdinfo/1
pos:    0
flags:  02
mnt_id: 9
ino:    12310
scm_fds: 0
```

> 尚未完成，以下內容未整理
{: .prompt-warning }

| Name             | Access Function               | Target / Related Structure        | Meaning                                                        |
| :--------------- | :----------------------------| :---------------------------------------------------- | :-------------------------------------------------------------|
| `fd`             | `proc_fd_readdir()`<br>`proc_fd_lookup()` | `task->files->fdt`                             | File descriptor table (open files)                              |
| `fdinfo`         | `proc_fdinfo_readdir()`<br>`proc_fdinfo_lookup()` | `task->files->fdt`                          | Detailed info per open file descriptor                          |
| `maps`           | `proc_pid_maps_operations`    | `task->mm->mmap`                                      | Memory mappings of the process                                  |
| `map_files`      | `proc_pid_map_files()`         | `task->mm->mmap`                                      | Files backing the memory mappings                               |
| `mem`            | `proc_mem_operations`          | `task->mm`                                            | Access to process memory                                        |
| `pagemap`        | `proc_pagemap_operations`      | `task->mm`                                            | Page mapping information                                       |
| `stack`          | `proc_pid_stack()`             | `task->stack`                                        | Kernel stack trace of the task                                  |
| `stat`           | `proc_tid_stat()`              | Various `task_struct` fields                           | Process and thread statistics                                  |
| `statm`          | `proc_pid_statm()`             | `task->mm`                                            | Process memory usage summary                                   |
| `status`         | `proc_pid_status()`            | Various `task_struct` fields                           | Detailed process status                                        |
| `cmdline`        | `proc_pid_cmdline_ops`         | `task->mm->arg_start` and `arg_end`                   | Command line arguments                                         |
| `environ`        | `proc_environ_operations`      | `task->mm->env_start` and `env_end`                   | Environment variables                                         |
| `auxv`           | `proc_auxv_operations`         | `task->mm->env_end`                                   | Auxiliary vector entries                                      |
| `comm`           | `proc_tid_comm_inode_operations` | `task->comm`                                        | Command name (short process name)                             |
| `oom_score`      | `proc_oom_score`               | `task->signal->oom_score`                             | Out-of-memory killer score                                    |
| `oom_adj`        | `proc_oom_adj_operations`      | `task->signal->oom_score_adj`                         | Adjust oom score                                              |
| `oom_score_adj`  | `proc_oom_score_adj_operations`| `task->signal->oom_score_adj`                         | Adjust oom score (new interface)                             |
| `limits`         | `proc_pid_limits()`             | Resource limits in `task->signal->rlim`               | Process resource limits                                      |
| `loginuid`       | `proc_loginuid_operations`      | `task->loginuid`                                      | Login user ID                                                |
| `sessionid`      | `proc_sessionid_operations`     | `task->sessionid`                                     | Session ID                                                  |
| `personality`    | `proc_pid_personality()`        | `task->personality`                                   | Process personality (execution domain)                       |
| `sched`          | `proc_pid_sched_operations`     | Scheduling info in `task_struct`                      | Scheduling parameters and statistics                         |
| `schedstat`      | `proc_pid_schedstat()`          | Scheduling stats                                       | Per-process scheduling statistics                            |
| `latency`        | `proc_lstats_operations`        | Latency information                                   | Latency monitoring                                           |
| `io`             | `proc_tid_io_accounting()`      | I/O accounting info                                   | Task I/O statistics                                          |
| `ns`             | `proc_ns_dir_operations`        | Various `task_struct` namespace fields                | Namespaces of the task                                       |
| `net`            | `proc_net_operations`           | Network info related to the process                   | Network namespace info                                      |
| `cgroup`         | `proc_cgroup_show()`            | `task->cgroups`                                      | Control group membership                                    |
| `cpuset`         | `proc_cpuset_show()`            | CPU sets                                              | CPU affinity settings                                       |
| `mounts`         | `proc_mounts_operations`        | Mount points from `task->fs->root`                     | Mounted filesystems                                         |
| `mountinfo`      | `proc_mountinfo_operations`     | Detailed mount info                                   | Mount namespace info                                       |
| `clear_refs`     | `proc_clear_refs_operations`    | Page monitoring flags                                | Clear page reference bits                                  |
| `smaps`          | `proc_pid_smaps_operations`     | Memory usage details                                 | Extended memory info                                       |
| `smaps_rollup`   | `proc_pid_smaps_rollup_operations` | Aggregated smaps                                    | Aggregated memory info                                    |
| `ksm_merging_pages` | `proc_pid_ksm_merging_pages`  | Kernel samepage merging info                          | KSM pages info                                            |
| `ksm_stat`       | `proc_pid_ksm_stat`             | KSM statistics                                       | Kernel samepage merging stats                             |
| `uid_map`        | `proc_uid_map_operations`       | User namespace mappings                              | User ID namespace maps                                    |
| `gid_map`        | `proc_gid_map_operations`       | Group namespace mappings                             | Group ID namespace maps                                   |
| `projid_map`     | `proc_projid_map_operations`    | Project ID mappings                                  | Project ID namespace maps                                |
| `setgroups`      | `proc_setgroups_operations`     | Setgroups configuration                             | Controls group setgroups                                  |
| `sessionid`      | `proc_sessionid_operations`     | Session ID                                          | Process session ID                                       |
| `personality`    | `proc_pid_personality`           | Personality flags                                   | Process personality                                     |
| `syscall`        | `proc_pid_syscall`               | Current syscall number                              | Syscall being executed                                  |
| `timers`         | `proc_timers_operations`         | Task timers                                        | Timers used by the process                             |
| `timens_offsets` | `proc_timens_offsets_operations`| Time namespace offsets                             | Time namespace data                                   |
| `wchan`          | `proc_pid_wchan`                 | Wait channel                                       | Kernel function where task is sleeping                 |
| `patch_state`    | `proc_pid_patch_state`           | Livepatch state                                   | Livepatch applied state                               |
| `latency`        | `proc_lstats_operations`         | Latency statistics                                | Latency monitoring                                    |



[^fn1]: 當然可以 `sudo ls`，但接下來要往內看細節時也會一直需要 `root` 權限，遇到目錄時甚至沒辦法 `sudo cd` 來進入，因此推薦直接使用 `root` 來操作，不要白目亂刪東西就好
